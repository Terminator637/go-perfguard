// Code generated by "precompile.go". DO NOT EDIT.

package rulesdata

import "github.com/quasilyte/go-ruleguard/ruleguard/ir"

var Universal = &ir.File{
	PkgPath:       "gorules",
	CustomDecls:   []string{},
	BundleImports: []ir.BundleImport{},
	RuleGroups: []ir.RuleGroup{
		ir.RuleGroup{
			Line:        27,
			Name:        "equalFold",
			MatcherName: "m",
			DocTags: []string{
				"o1",
			},
			DocSummary: "Detects unoptimal strings/bytes case-insensitive comparison",
			DocBefore:  "strings.ToLower(x) == strings.ToLower(y)",
			DocAfter:   "strings.EqualFold(x, y)",
			Rules: []ir.Rule{
				ir.Rule{
					Line: 29,
					SyntaxPatterns: []ir.PatternString{
						ir.PatternString{Line: 30, Value: "strings.ToLower($x) == $y"},
						ir.PatternString{Line: 31, Value: "strings.ToLower($x) == strings.ToLower($y)"},
						ir.PatternString{Line: 32, Value: "$x == strings.ToLower($y)"},
						ir.PatternString{Line: 33, Value: "strings.ToUpper($x) == $y"},
						ir.PatternString{Line: 34, Value: "strings.ToUpper($x) == strings.ToUpper($y)"},
						ir.PatternString{Line: 35, Value: "$x == strings.ToUpper($y)"},
					},
					ReportTemplate:  "$$ => strings.EqualFold($x, $y)",
					SuggestTemplate: "strings.EqualFold($x, $y)",
					WhereExpr: ir.FilterExpr{
						Line: 36,
						Op:   ir.FilterAndOp,
						Src:  "m[\"x\"].Pure && m[\"y\"].Pure && m[\"x\"].Text != m[\"y\"].Text",
						Args: []ir.FilterExpr{
							ir.FilterExpr{
								Line: 36,
								Op:   ir.FilterAndOp,
								Src:  "m[\"x\"].Pure && m[\"y\"].Pure",
								Args: []ir.FilterExpr{
									ir.FilterExpr{Line: 36, Op: ir.FilterVarPureOp, Src: "m[\"x\"].Pure", Value: "x"},
									ir.FilterExpr{Line: 36, Op: ir.FilterVarPureOp, Src: "m[\"y\"].Pure", Value: "y"},
								},
							},
							ir.FilterExpr{
								Line: 36,
								Op:   ir.FilterNeqOp,
								Src:  "m[\"x\"].Text != m[\"y\"].Text",
								Args: []ir.FilterExpr{
									ir.FilterExpr{Line: 36, Op: ir.FilterVarTextOp, Src: "m[\"x\"].Text", Value: "x"},
									ir.FilterExpr{Line: 36, Op: ir.FilterVarTextOp, Src: "m[\"y\"].Text", Value: "y"},
								},
							},
						},
					},
				},
				ir.Rule{
					Line: 40,
					SyntaxPatterns: []ir.PatternString{
						ir.PatternString{Line: 41, Value: "strings.ToLower($x) != $y"},
						ir.PatternString{Line: 42, Value: "strings.ToLower($x) != strings.ToLower($y)"},
						ir.PatternString{Line: 43, Value: "$x != strings.ToLower($y)"},
						ir.PatternString{Line: 44, Value: "strings.ToUpper($x) != $y"},
						ir.PatternString{Line: 45, Value: "strings.ToUpper($x) != strings.ToUpper($y)"},
						ir.PatternString{Line: 46, Value: "$x != strings.ToUpper($y)"},
					},
					ReportTemplate:  "$$ => !strings.EqualFold($x, $y)",
					SuggestTemplate: "!strings.EqualFold($x, $y)",
					WhereExpr: ir.FilterExpr{
						Line: 47,
						Op:   ir.FilterAndOp,
						Src:  "m[\"x\"].Pure && m[\"y\"].Pure && m[\"x\"].Text != m[\"y\"].Text",
						Args: []ir.FilterExpr{
							ir.FilterExpr{
								Line: 47,
								Op:   ir.FilterAndOp,
								Src:  "m[\"x\"].Pure && m[\"y\"].Pure",
								Args: []ir.FilterExpr{
									ir.FilterExpr{Line: 47, Op: ir.FilterVarPureOp, Src: "m[\"x\"].Pure", Value: "x"},
									ir.FilterExpr{Line: 47, Op: ir.FilterVarPureOp, Src: "m[\"y\"].Pure", Value: "y"},
								},
							},
							ir.FilterExpr{
								Line: 47,
								Op:   ir.FilterNeqOp,
								Src:  "m[\"x\"].Text != m[\"y\"].Text",
								Args: []ir.FilterExpr{
									ir.FilterExpr{Line: 47, Op: ir.FilterVarTextOp, Src: "m[\"x\"].Text", Value: "x"},
									ir.FilterExpr{Line: 47, Op: ir.FilterVarTextOp, Src: "m[\"y\"].Text", Value: "y"},
								},
							},
						},
					},
				},
				ir.Rule{
					Line: 51,
					SyntaxPatterns: []ir.PatternString{
						ir.PatternString{Line: 52, Value: "bytes.Equal(bytes.ToLower($x), $y)"},
						ir.PatternString{Line: 53, Value: "bytes.Equal(bytes.ToLower($x), bytes.ToLower($y))"},
						ir.PatternString{Line: 54, Value: "bytes.Equal($x, bytes.ToLower($y))"},
						ir.PatternString{Line: 55, Value: "bytes.Equal(bytes.ToUpper($x), $y)"},
						ir.PatternString{Line: 56, Value: "bytes.Equal(bytes.ToUpper($x), bytes.ToUpper($y))"},
						ir.PatternString{Line: 57, Value: "bytes.Equal($x, bytes.ToUpper($y))"},
					},
					ReportTemplate:  "$$ => bytes.EqualFold($x, $y)",
					SuggestTemplate: "bytes.EqualFold($x, $y)",
					WhereExpr: ir.FilterExpr{
						Line: 58,
						Op:   ir.FilterAndOp,
						Src:  "m[\"x\"].Pure && m[\"y\"].Pure && m[\"x\"].Text != m[\"y\"].Text",
						Args: []ir.FilterExpr{
							ir.FilterExpr{
								Line: 58,
								Op:   ir.FilterAndOp,
								Src:  "m[\"x\"].Pure && m[\"y\"].Pure",
								Args: []ir.FilterExpr{
									ir.FilterExpr{Line: 58, Op: ir.FilterVarPureOp, Src: "m[\"x\"].Pure", Value: "x"},
									ir.FilterExpr{Line: 58, Op: ir.FilterVarPureOp, Src: "m[\"y\"].Pure", Value: "y"},
								},
							},
							ir.FilterExpr{
								Line: 58,
								Op:   ir.FilterNeqOp,
								Src:  "m[\"x\"].Text != m[\"y\"].Text",
								Args: []ir.FilterExpr{
									ir.FilterExpr{Line: 58, Op: ir.FilterVarTextOp, Src: "m[\"x\"].Text", Value: "x"},
									ir.FilterExpr{Line: 58, Op: ir.FilterVarTextOp, Src: "m[\"y\"].Text", Value: "y"},
								},
							},
						},
					},
				},
			},
		},
		ir.RuleGroup{
			Line:        64,
			Name:        "redundantSprint",
			MatcherName: "m",
			DocTags: []string{
				"o1",
			},
			DocSummary: "Detects redundant fmt.Sprint calls",
			Rules: []ir.Rule{
				ir.Rule{
					Line: 65,
					SyntaxPatterns: []ir.PatternString{
						ir.PatternString{Line: 65, Value: "fmt.Sprint($x)"},
						ir.PatternString{Line: 65, Value: "fmt.Sprintf(\"%s\", $x)"},
						ir.PatternString{Line: 65, Value: "fmt.Sprintf(\"%v\", $x)"},
					},
					ReportTemplate:  "$$ => $x.String()",
					SuggestTemplate: "$x.String()",
					WhereExpr: ir.FilterExpr{
						Line:  66,
						Op:    ir.FilterVarTypeImplementsOp,
						Src:   "m[\"x\"].Type.Implements(`fmt.Stringer`)",
						Value: "x",
						Args: []ir.FilterExpr{
							ir.FilterExpr{Line: 66, Op: ir.FilterStringOp, Src: "`fmt.Stringer`", Value: "fmt.Stringer"},
						},
					},
				},
				ir.Rule{
					Line: 69,
					SyntaxPatterns: []ir.PatternString{
						ir.PatternString{Line: 69, Value: "fmt.Sprint($x)"},
						ir.PatternString{Line: 69, Value: "fmt.Sprintf(\"%s\", $x)"},
						ir.PatternString{Line: 69, Value: "fmt.Sprintf(\"%v\", $x)"},
					},
					ReportTemplate:  "$$ => $x.Error()",
					SuggestTemplate: "$x.Error()",
					WhereExpr: ir.FilterExpr{
						Line:  70,
						Op:    ir.FilterVarTypeImplementsOp,
						Src:   "m[\"x\"].Type.Implements(`error`)",
						Value: "x",
						Args: []ir.FilterExpr{
							ir.FilterExpr{Line: 70, Op: ir.FilterStringOp, Src: "`error`", Value: "error"},
						},
					},
				},
				ir.Rule{
					Line: 73,
					SyntaxPatterns: []ir.PatternString{
						ir.PatternString{Line: 73, Value: "fmt.Sprint($x)"},
						ir.PatternString{Line: 73, Value: "fmt.Sprintf(\"%s\", $x)"},
						ir.PatternString{Line: 73, Value: "fmt.Sprintf(\"%v\", $x)"},
					},
					ReportTemplate:  "$$ => $x",
					SuggestTemplate: "$x",
					WhereExpr: ir.FilterExpr{
						Line:  74,
						Op:    ir.FilterVarTypeIsOp,
						Src:   "m[\"x\"].Type.Is(`string`)",
						Value: "x",
						Args: []ir.FilterExpr{
							ir.FilterExpr{Line: 74, Op: ir.FilterStringOp, Src: "`string`", Value: "string"},
						},
					},
				},
			},
		},
		ir.RuleGroup{
			Line:        80,
			Name:        "stringsJoinConcat",
			MatcherName: "m",
			DocTags: []string{
				"o1",
			},
			DocSummary: "Detect strings.Join usages that can be rewritten as a string concat",
			Rules: []ir.Rule{
				ir.Rule{
					Line: 81,
					SyntaxPatterns: []ir.PatternString{
						ir.PatternString{Line: 81, Value: "strings.Join([]string{$x, $y}, \"\")"},
					},
					ReportTemplate:  "$$ => $x + $y",
					SuggestTemplate: "$x + $y",
				},
				ir.Rule{
					Line: 82,
					SyntaxPatterns: []ir.PatternString{
						ir.PatternString{Line: 82, Value: "strings.Join([]string{$x, $y, $z}, \"\")"},
					},
					ReportTemplate:  "$$ => $x + $y + $z",
					SuggestTemplate: "$x + $y + $z",
				},
				ir.Rule{
					Line: 84,
					SyntaxPatterns: []ir.PatternString{
						ir.PatternString{Line: 84, Value: "strings.Join([]string{$x, $y}, $glue)"},
					},
					ReportTemplate:  "$$ => $x + $glue + $y",
					SuggestTemplate: "$x + $glue + $y",
				},
				ir.Rule{
					Line: 86,
					SyntaxPatterns: []ir.PatternString{
						ir.PatternString{Line: 86, Value: "strings.Join([]string{$x, $y, $z}, $glue)"},
					},
					ReportTemplate:  "$$ => $x + $glue + $y + $glue + $z",
					SuggestTemplate: "$x + $glue + $y + $glue + $z",
					WhereExpr:       ir.FilterExpr{Line: 87, Op: ir.FilterVarPureOp, Src: "m[\"glue\"].Pure", Value: "glue"},
				},
			},
		},
		ir.RuleGroup{
			Line:        95,
			Name:        "sprintConcat",
			MatcherName: "m",
			DocTags: []string{
				"o1",
			},
			DocSummary: "Detects sprint calls that can be rewritten as a string concat",
			DocBefore:  "fmt.Sprintf(\"%s%s\", x, y)",
			DocAfter:   "x + y",
			Rules: []ir.Rule{
				ir.Rule{
					Line: 96,
					SyntaxPatterns: []ir.PatternString{
						ir.PatternString{Line: 96, Value: "fmt.Sprintf(\"%s%s\", $x, $y)"},
					},
					ReportTemplate:  "$$ => $x + $y",
					SuggestTemplate: "$x + $y",
					WhereExpr: ir.FilterExpr{
						Line: 97,
						Op:   ir.FilterAndOp,
						Src:  "m[\"x\"].Type.Is(`string`) && m[\"y\"].Type.Is(`string`)",
						Args: []ir.FilterExpr{
							ir.FilterExpr{
								Line:  97,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"x\"].Type.Is(`string`)",
								Value: "x",
								Args: []ir.FilterExpr{
									ir.FilterExpr{Line: 97, Op: ir.FilterStringOp, Src: "`string`", Value: "string"},
								},
							},
							ir.FilterExpr{
								Line:  97,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"y\"].Type.Is(`string`)",
								Value: "y",
								Args: []ir.FilterExpr{
									ir.FilterExpr{Line: 97, Op: ir.FilterStringOp, Src: "`string`", Value: "string"},
								},
							},
						},
					},
				},
				ir.Rule{
					Line: 100,
					SyntaxPatterns: []ir.PatternString{
						ir.PatternString{Line: 100, Value: "fmt.Sprintf(\"%s%s\", $x, $y)"},
					},
					ReportTemplate:  "$$ => $x.String() + $y.String()",
					SuggestTemplate: "$x.String() + $y.String()",
					WhereExpr: ir.FilterExpr{
						Line: 101,
						Op:   ir.FilterAndOp,
						Src:  "m[\"x\"].Type.Implements(`fmt.Stringer`) && m[\"y\"].Type.Implements(`fmt.Stringer`)",
						Args: []ir.FilterExpr{
							ir.FilterExpr{
								Line:  101,
								Op:    ir.FilterVarTypeImplementsOp,
								Src:   "m[\"x\"].Type.Implements(`fmt.Stringer`)",
								Value: "x",
								Args: []ir.FilterExpr{
									ir.FilterExpr{Line: 101, Op: ir.FilterStringOp, Src: "`fmt.Stringer`", Value: "fmt.Stringer"},
								},
							},
							ir.FilterExpr{
								Line:  101,
								Op:    ir.FilterVarTypeImplementsOp,
								Src:   "m[\"y\"].Type.Implements(`fmt.Stringer`)",
								Value: "y",
								Args: []ir.FilterExpr{
									ir.FilterExpr{Line: 101, Op: ir.FilterStringOp, Src: "`fmt.Stringer`", Value: "fmt.Stringer"},
								},
							},
						},
					},
				},
			},
		},
		ir.RuleGroup{
			Line:        109,
			Name:        "strconv",
			MatcherName: "m",
			DocTags: []string{
				"o1",
			},
			DocSummary: "Detects fmt uses that can be replaced with strconv",
			DocBefore:  "fmt.Sprintf(\"%d\", i)",
			DocAfter:   "strconv.Itoa(i)",
			Rules: []ir.Rule{
				ir.Rule{
					Line: 113,
					SyntaxPatterns: []ir.PatternString{
						ir.PatternString{Line: 113, Value: "fmt.Sprintf(\"%d\", $x)"},
						ir.PatternString{Line: 113, Value: "fmt.Sprintf(\"%v\", $x)"},
						ir.PatternString{Line: 113, Value: "fmt.Sprint($x)"},
					},
					ReportTemplate:  "$$ => strconv.Itoa($x)",
					SuggestTemplate: "strconv.Itoa($x)",
					WhereExpr: ir.FilterExpr{
						Line:  114,
						Op:    ir.FilterVarTypeIsOp,
						Src:   "m[\"x\"].Type.Is(`int`)",
						Value: "x",
						Args: []ir.FilterExpr{
							ir.FilterExpr{Line: 114, Op: ir.FilterStringOp, Src: "`int`", Value: "int"},
						},
					},
				},
				ir.Rule{
					Line: 118,
					SyntaxPatterns: []ir.PatternString{
						ir.PatternString{Line: 118, Value: "fmt.Sprintf(\"%d\", $x)"},
						ir.PatternString{Line: 118, Value: "fmt.Sprintf(\"%v\", $x)"},
						ir.PatternString{Line: 118, Value: "fmt.Sprint($x)"},
					},
					ReportTemplate:  "$$ => strconv.FormatInt($x, 10)",
					SuggestTemplate: "strconv.FormatInt($x, 10)",
					WhereExpr: ir.FilterExpr{
						Line:  119,
						Op:    ir.FilterVarTypeIsOp,
						Src:   "m[\"x\"].Type.Is(`int64`)",
						Value: "x",
						Args: []ir.FilterExpr{
							ir.FilterExpr{Line: 119, Op: ir.FilterStringOp, Src: "`int64`", Value: "int64"},
						},
					},
				},
				ir.Rule{
					Line: 120,
					SyntaxPatterns: []ir.PatternString{
						ir.PatternString{Line: 120, Value: "fmt.Sprintf(\"%x\", $x)"},
					},
					ReportTemplate:  "$$ => strconv.FormatInt($x, 16)",
					SuggestTemplate: "strconv.FormatInt($x, 16)",
					WhereExpr: ir.FilterExpr{
						Line:  121,
						Op:    ir.FilterVarTypeIsOp,
						Src:   "m[\"x\"].Type.Is(`int64`)",
						Value: "x",
						Args: []ir.FilterExpr{
							ir.FilterExpr{Line: 121, Op: ir.FilterStringOp, Src: "`int64`", Value: "int64"},
						},
					},
				},
				ir.Rule{
					Line: 122,
					SyntaxPatterns: []ir.PatternString{
						ir.PatternString{Line: 122, Value: "fmt.Sprintf(\"%d\", $x)"},
						ir.PatternString{Line: 122, Value: "fmt.Sprintf(\"%v\", $x)"},
						ir.PatternString{Line: 122, Value: "fmt.Sprint($x)"},
					},
					ReportTemplate:  "$$ => strconv.FormatUint($x, 10)",
					SuggestTemplate: "strconv.FormatUint($x, 10)",
					WhereExpr: ir.FilterExpr{
						Line:  123,
						Op:    ir.FilterVarTypeIsOp,
						Src:   "m[\"x\"].Type.Is(`uint64`)",
						Value: "x",
						Args: []ir.FilterExpr{
							ir.FilterExpr{Line: 123, Op: ir.FilterStringOp, Src: "`uint64`", Value: "uint64"},
						},
					},
				},
				ir.Rule{
					Line: 124,
					SyntaxPatterns: []ir.PatternString{
						ir.PatternString{Line: 124, Value: "fmt.Sprintf(\"%x\", $x)"},
					},
					ReportTemplate:  "$$ => strconv.FormatUint($x, 16)",
					SuggestTemplate: "strconv.FormatUint($x, 16)",
					WhereExpr: ir.FilterExpr{
						Line:  125,
						Op:    ir.FilterVarTypeIsOp,
						Src:   "m[\"x\"].Type.Is(`uint64`)",
						Value: "x",
						Args: []ir.FilterExpr{
							ir.FilterExpr{Line: 125, Op: ir.FilterStringOp, Src: "`uint64`", Value: "uint64"},
						},
					},
				},
				ir.Rule{
					Line: 127,
					SyntaxPatterns: []ir.PatternString{
						ir.PatternString{Line: 127, Value: "fmt.Sprintf(\"%d\", $x)"},
						ir.PatternString{Line: 127, Value: "fmt.Sprintf(\"%v\", $x)"},
						ir.PatternString{Line: 127, Value: "fmt.Sprint($x)"},
					},
					ReportTemplate:  "$$ => strconv.FormatInt(int64($x), 10)",
					SuggestTemplate: "strconv.FormatInt(int64($x), 10)",
					WhereExpr: ir.FilterExpr{
						Line:  128,
						Op:    ir.FilterVarTypeOfKindOp,
						Src:   "m[\"x\"].Type.OfKind(`int`)",
						Value: "x",
						Args: []ir.FilterExpr{
							ir.FilterExpr{Line: 128, Op: ir.FilterStringOp, Src: "`int`", Value: "int"},
						},
					},
				},
				ir.Rule{
					Line: 129,
					SyntaxPatterns: []ir.PatternString{
						ir.PatternString{Line: 129, Value: "fmt.Sprintf(\"%x\", $x)"},
					},
					ReportTemplate:  "$$ => strconv.FormatInt(int64($x), 16)",
					SuggestTemplate: "strconv.FormatInt(int64($x), 16)",
					WhereExpr: ir.FilterExpr{
						Line:  130,
						Op:    ir.FilterVarTypeOfKindOp,
						Src:   "m[\"x\"].Type.OfKind(`int`)",
						Value: "x",
						Args: []ir.FilterExpr{
							ir.FilterExpr{Line: 130, Op: ir.FilterStringOp, Src: "`int`", Value: "int"},
						},
					},
				},
				ir.Rule{
					Line: 132,
					SyntaxPatterns: []ir.PatternString{
						ir.PatternString{Line: 132, Value: "fmt.Sprintf(\"%d\", $x)"},
						ir.PatternString{Line: 132, Value: "fmt.Sprintf(\"%v\", $x)"},
						ir.PatternString{Line: 132, Value: "fmt.Sprint($x)"},
					},
					ReportTemplate:  "$$ => strconv.FormatUint(uint64($x), 10)",
					SuggestTemplate: "strconv.FormatUint(uint64($x), 10)",
					WhereExpr: ir.FilterExpr{
						Line:  133,
						Op:    ir.FilterVarTypeOfKindOp,
						Src:   "m[\"x\"].Type.OfKind(`uint`)",
						Value: "x",
						Args: []ir.FilterExpr{
							ir.FilterExpr{Line: 133, Op: ir.FilterStringOp, Src: "`uint`", Value: "uint"},
						},
					},
				},
				ir.Rule{
					Line: 134,
					SyntaxPatterns: []ir.PatternString{
						ir.PatternString{Line: 134, Value: "fmt.Sprintf(\"%x\", $x)"},
					},
					ReportTemplate:  "$$ => strconv.FormatUint(uint64($x), 16)",
					SuggestTemplate: "strconv.FormatUint(uint64($x), 16)",
					WhereExpr: ir.FilterExpr{
						Line:  135,
						Op:    ir.FilterVarTypeOfKindOp,
						Src:   "m[\"x\"].Type.OfKind(`uint`)",
						Value: "x",
						Args: []ir.FilterExpr{
							ir.FilterExpr{Line: 135, Op: ir.FilterStringOp, Src: "`uint`", Value: "uint"},
						},
					},
				},
			},
		},
		ir.RuleGroup{
			Line:        142,
			Name:        "appendAPI",
			MatcherName: "m",
			DocTags: []string{
				"o1",
			},
			DocSummary: "Detects cases that can benefit from append-friendly APIs",
			DocBefore:  "b = append(b, strconv.Itoa(v)...)",
			DocAfter:   "b = strconv.AppendInt(b, v, 10)",
			Rules: []ir.Rule{
				ir.Rule{
					Line: 150,
					SyntaxPatterns: []ir.PatternString{
						ir.PatternString{Line: 150, Value: "$b = append($b, strconv.Itoa($x)...)"},
					},
					ReportTemplate:  "$$ => $b = strconv.AppendInt($b, int64($x), 10)",
					SuggestTemplate: "$b = strconv.AppendInt($b, int64($x), 10)",
				},
				ir.Rule{
					Line: 152,
					SyntaxPatterns: []ir.PatternString{
						ir.PatternString{Line: 152, Value: "$b = append($b, strconv.FormatInt($x, $base)...)"},
					},
					ReportTemplate:  "$$ => $b = strconv.AppendInt($b, $x, $base)",
					SuggestTemplate: "$b = strconv.AppendInt($b, $x, $base)",
				},
				ir.Rule{
					Line: 154,
					SyntaxPatterns: []ir.PatternString{
						ir.PatternString{Line: 154, Value: "$b = append($b, strconv.FormatUint($x, $base)...)"},
					},
					ReportTemplate:  "$$ => $b = strconv.AppendUint($b, $x, $base)",
					SuggestTemplate: "$b = strconv.AppendUint($b, $x, $base)",
				},
				ir.Rule{
					Line: 157,
					SyntaxPatterns: []ir.PatternString{
						ir.PatternString{Line: 157, Value: "$b = append($b, $t.Format($layout)...)"},
					},
					ReportTemplate:  "$$ => $b = $t.AppendFormat($b, $layout)",
					SuggestTemplate: "$b = $t.AppendFormat($b, $layout)",
					WhereExpr: ir.FilterExpr{
						Line: 158,
						Op:   ir.FilterOrOp,
						Src:  "m[\"t\"].Type.Is(`time.Time`) || m[\"t\"].Type.Is(`*time.Time`)",
						Args: []ir.FilterExpr{
							ir.FilterExpr{
								Line:  158,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"t\"].Type.Is(`time.Time`)",
								Value: "t",
								Args: []ir.FilterExpr{
									ir.FilterExpr{Line: 158, Op: ir.FilterStringOp, Src: "`time.Time`", Value: "time.Time"},
								},
							},
							ir.FilterExpr{
								Line:  158,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"t\"].Type.Is(`*time.Time`)",
								Value: "t",
								Args: []ir.FilterExpr{
									ir.FilterExpr{Line: 158, Op: ir.FilterStringOp, Src: "`*time.Time`", Value: "*time.Time"},
								},
							},
						},
					},
				},
				ir.Rule{
					Line: 161,
					SyntaxPatterns: []ir.PatternString{
						ir.PatternString{Line: 161, Value: "$b = append($b, $v.String()...)"},
					},
					ReportTemplate:  "$$ => $b = $v.Append($b, 'g', 10)",
					SuggestTemplate: "$b = $v.Append($b, 'g', 10)",
					WhereExpr: ir.FilterExpr{
						Line: 162,
						Op:   ir.FilterOrOp,
						Src:  "m[\"v\"].Type.Is(`big.Float`) || m[\"v\"].Type.Is(`*big.Float`)",
						Args: []ir.FilterExpr{
							ir.FilterExpr{
								Line:  162,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"v\"].Type.Is(`big.Float`)",
								Value: "v",
								Args: []ir.FilterExpr{
									ir.FilterExpr{Line: 162, Op: ir.FilterStringOp, Src: "`big.Float`", Value: "big.Float"},
								},
							},
							ir.FilterExpr{
								Line:  162,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"v\"].Type.Is(`*big.Float`)",
								Value: "v",
								Args: []ir.FilterExpr{
									ir.FilterExpr{Line: 162, Op: ir.FilterStringOp, Src: "`*big.Float`", Value: "*big.Float"},
								},
							},
						},
					},
				},
				ir.Rule{
					Line: 164,
					SyntaxPatterns: []ir.PatternString{
						ir.PatternString{Line: 164, Value: "$b = append($b, $v.Text($format, $prec)...)"},
					},
					ReportTemplate:  "$$ => $b = $v.Append($b, $format, $prec)",
					SuggestTemplate: "$b = $v.Append($b, $format, $prec)",
					WhereExpr: ir.FilterExpr{
						Line: 165,
						Op:   ir.FilterOrOp,
						Src:  "m[\"v\"].Type.Is(`big.Float`) || m[\"v\"].Type.Is(`*big.Float`)",
						Args: []ir.FilterExpr{
							ir.FilterExpr{
								Line:  165,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"v\"].Type.Is(`big.Float`)",
								Value: "v",
								Args: []ir.FilterExpr{
									ir.FilterExpr{Line: 165, Op: ir.FilterStringOp, Src: "`big.Float`", Value: "big.Float"},
								},
							},
							ir.FilterExpr{
								Line:  165,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"v\"].Type.Is(`*big.Float`)",
								Value: "v",
								Args: []ir.FilterExpr{
									ir.FilterExpr{Line: 165, Op: ir.FilterStringOp, Src: "`*big.Float`", Value: "*big.Float"},
								},
							},
						},
					},
				},
				ir.Rule{
					Line: 168,
					SyntaxPatterns: []ir.PatternString{
						ir.PatternString{Line: 168, Value: "$b = append($b, $v.String()...)"},
					},
					ReportTemplate:  "$$ => $b = $v.Append($b, 10)",
					SuggestTemplate: "$b = $v.Append($b, 10)",
					WhereExpr: ir.FilterExpr{
						Line: 169,
						Op:   ir.FilterOrOp,
						Src:  "m[\"v\"].Type.Is(`big.Int`) || m[\"v\"].Type.Is(`*big.Int`)",
						Args: []ir.FilterExpr{
							ir.FilterExpr{
								Line:  169,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"v\"].Type.Is(`big.Int`)",
								Value: "v",
								Args: []ir.FilterExpr{
									ir.FilterExpr{Line: 169, Op: ir.FilterStringOp, Src: "`big.Int`", Value: "big.Int"},
								},
							},
							ir.FilterExpr{
								Line:  169,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"v\"].Type.Is(`*big.Int`)",
								Value: "v",
								Args: []ir.FilterExpr{
									ir.FilterExpr{Line: 169, Op: ir.FilterStringOp, Src: "`*big.Int`", Value: "*big.Int"},
								},
							},
						},
					},
				},
				ir.Rule{
					Line: 171,
					SyntaxPatterns: []ir.PatternString{
						ir.PatternString{Line: 171, Value: "$b = append($b, $v.Text($base)...)"},
					},
					ReportTemplate:  "$$ => $b = $v.Append($b, $base)",
					SuggestTemplate: "$b = $v.Append($b, $base)",
					WhereExpr: ir.FilterExpr{
						Line: 172,
						Op:   ir.FilterOrOp,
						Src:  "m[\"v\"].Type.Is(`big.Int`) || m[\"v\"].Type.Is(`*big.Int`)",
						Args: []ir.FilterExpr{
							ir.FilterExpr{
								Line:  172,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"v\"].Type.Is(`big.Int`)",
								Value: "v",
								Args: []ir.FilterExpr{
									ir.FilterExpr{Line: 172, Op: ir.FilterStringOp, Src: "`big.Int`", Value: "big.Int"},
								},
							},
							ir.FilterExpr{
								Line:  172,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"v\"].Type.Is(`*big.Int`)",
								Value: "v",
								Args: []ir.FilterExpr{
									ir.FilterExpr{Line: 172, Op: ir.FilterStringOp, Src: "`*big.Int`", Value: "*big.Int"},
								},
							},
						},
					},
				},
			},
		},
		ir.RuleGroup{
			Line:        180,
			Name:        "stringCopyElim",
			MatcherName: "m",
			DocTags: []string{
				"o1",
			},
			DocSummary: "Detects redundant conversions between string and []byte",
			DocBefore:  "copy(b, []byte(s))",
			DocAfter:   "copy(b, s)",
			Rules: []ir.Rule{
				ir.Rule{
					Line: 181,
					SyntaxPatterns: []ir.PatternString{
						ir.PatternString{Line: 181, Value: "copy($b, []byte($s))"},
					},
					ReportTemplate:  "$$ => copy($b, $s)",
					SuggestTemplate: "copy($b, $s)",
					WhereExpr: ir.FilterExpr{
						Line:  182,
						Op:    ir.FilterVarTypeIsOp,
						Src:   "m[\"s\"].Type.Is(`string`)",
						Value: "s",
						Args: []ir.FilterExpr{
							ir.FilterExpr{Line: 182, Op: ir.FilterStringOp, Src: "`string`", Value: "string"},
						},
					},
				},
				ir.Rule{
					Line: 185,
					SyntaxPatterns: []ir.PatternString{
						ir.PatternString{Line: 185, Value: "append($b, []byte($s)...)"},
					},
					ReportTemplate:  "$$ => append($b, $s...)",
					SuggestTemplate: "append($b, $s...)",
					WhereExpr: ir.FilterExpr{
						Line:  186,
						Op:    ir.FilterVarTypeIsOp,
						Src:   "m[\"s\"].Type.Is(`string`)",
						Value: "s",
						Args: []ir.FilterExpr{
							ir.FilterExpr{Line: 186, Op: ir.FilterStringOp, Src: "`string`", Value: "string"},
						},
					},
				},
				ir.Rule{
					Line: 189,
					SyntaxPatterns: []ir.PatternString{
						ir.PatternString{Line: 189, Value: "len(string($b))"},
					},
					ReportTemplate:  "$$ => len($b)",
					SuggestTemplate: "len($b)",
					WhereExpr: ir.FilterExpr{
						Line:  189,
						Op:    ir.FilterVarTypeIsOp,
						Src:   "m[\"b\"].Type.Is(`[]byte`)",
						Value: "b",
						Args: []ir.FilterExpr{
							ir.FilterExpr{Line: 189, Op: ir.FilterStringOp, Src: "`[]byte`", Value: "[]byte"},
						},
					},
				},
				ir.Rule{
					Line: 191,
					SyntaxPatterns: []ir.PatternString{
						ir.PatternString{Line: 191, Value: "$re.Match([]byte($s))"},
					},
					ReportTemplate:  "$$ => $re.MatchString($s)",
					SuggestTemplate: "$re.MatchString($s)",
					WhereExpr: ir.FilterExpr{
						Line: 192,
						Op:   ir.FilterAndOp,
						Src:  "m[\"re\"].Type.Is(`*regexp.Regexp`) && m[\"s\"].Type.Is(`string`)",
						Args: []ir.FilterExpr{
							ir.FilterExpr{
								Line:  192,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"re\"].Type.Is(`*regexp.Regexp`)",
								Value: "re",
								Args: []ir.FilterExpr{
									ir.FilterExpr{Line: 192, Op: ir.FilterStringOp, Src: "`*regexp.Regexp`", Value: "*regexp.Regexp"},
								},
							},
							ir.FilterExpr{
								Line:  192,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"s\"].Type.Is(`string`)",
								Value: "s",
								Args: []ir.FilterExpr{
									ir.FilterExpr{Line: 192, Op: ir.FilterStringOp, Src: "`string`", Value: "string"},
								},
							},
						},
					},
				},
				ir.Rule{
					Line: 195,
					SyntaxPatterns: []ir.PatternString{
						ir.PatternString{Line: 195, Value: "$re.FindIndex([]byte($s))"},
					},
					ReportTemplate:  "$$ => $re.FindStringIndex($s)",
					SuggestTemplate: "$re.FindStringIndex($s)",
					WhereExpr: ir.FilterExpr{
						Line: 196,
						Op:   ir.FilterAndOp,
						Src:  "m[\"re\"].Type.Is(`*regexp.Regexp`) && m[\"s\"].Type.Is(`string`)",
						Args: []ir.FilterExpr{
							ir.FilterExpr{
								Line:  196,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"re\"].Type.Is(`*regexp.Regexp`)",
								Value: "re",
								Args: []ir.FilterExpr{
									ir.FilterExpr{Line: 196, Op: ir.FilterStringOp, Src: "`*regexp.Regexp`", Value: "*regexp.Regexp"},
								},
							},
							ir.FilterExpr{
								Line:  196,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"s\"].Type.Is(`string`)",
								Value: "s",
								Args: []ir.FilterExpr{
									ir.FilterExpr{Line: 196, Op: ir.FilterStringOp, Src: "`string`", Value: "string"},
								},
							},
						},
					},
				},
				ir.Rule{
					Line: 199,
					SyntaxPatterns: []ir.PatternString{
						ir.PatternString{Line: 199, Value: "$re.FindAllIndex([]byte($s), $n)"},
					},
					ReportTemplate:  "$$ => $re.FindAllStringIndex($s, $n)",
					SuggestTemplate: "$re.FindAllStringIndex($s, $n)",
					WhereExpr: ir.FilterExpr{
						Line: 200,
						Op:   ir.FilterAndOp,
						Src:  "m[\"re\"].Type.Is(`*regexp.Regexp`) && m[\"s\"].Type.Is(`string`)",
						Args: []ir.FilterExpr{
							ir.FilterExpr{
								Line:  200,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"re\"].Type.Is(`*regexp.Regexp`)",
								Value: "re",
								Args: []ir.FilterExpr{
									ir.FilterExpr{Line: 200, Op: ir.FilterStringOp, Src: "`*regexp.Regexp`", Value: "*regexp.Regexp"},
								},
							},
							ir.FilterExpr{
								Line:  200,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"s\"].Type.Is(`string`)",
								Value: "s",
								Args: []ir.FilterExpr{
									ir.FilterExpr{Line: 200, Op: ir.FilterStringOp, Src: "`string`", Value: "string"},
								},
							},
						},
					},
				},
			},
		},
		ir.RuleGroup{
			Line:        209,
			Name:        "indexAlloc",
			MatcherName: "m",
			DocTags: []string{
				"o1",
			},
			DocSummary: "Detects strings.Index calls that may cause unwanted allocs",
			DocBefore:  "strings.Index(string(x), y)",
			DocAfter:   "bytes.Index(x, []byte(y))",
			DocNote:    "See Go issue for details: https://github.com/golang/go/issues/25864",
			Rules: []ir.Rule{
				ir.Rule{
					Line: 210,
					SyntaxPatterns: []ir.PatternString{
						ir.PatternString{Line: 210, Value: "strings.Index(string($x), $y)"},
					},
					ReportTemplate:  "$$ => bytes.Index($x, []byte($y))",
					SuggestTemplate: "bytes.Index($x, []byte($y))",
					WhereExpr: ir.FilterExpr{
						Line: 211,
						Op:   ir.FilterAndOp,
						Src:  "m[\"x\"].Pure && m[\"y\"].Pure && m.File().Imports(`bytes`)",
						Args: []ir.FilterExpr{
							ir.FilterExpr{
								Line: 211,
								Op:   ir.FilterAndOp,
								Src:  "m[\"x\"].Pure && m[\"y\"].Pure",
								Args: []ir.FilterExpr{
									ir.FilterExpr{Line: 211, Op: ir.FilterVarPureOp, Src: "m[\"x\"].Pure", Value: "x"},
									ir.FilterExpr{Line: 211, Op: ir.FilterVarPureOp, Src: "m[\"y\"].Pure", Value: "y"},
								},
							},
							ir.FilterExpr{
								Line:  211,
								Op:    ir.FilterFileImportsOp,
								Src:   "m.File().Imports(`bytes`)",
								Value: "bytes",
							},
						},
					},
				},
			},
		},
		ir.RuleGroup{
			Line:        219,
			Name:        "writeByte",
			MatcherName: "m",
			DocTags: []string{
				"o1",
			},
			DocSummary: "Detects WriteRune calls with rune literal argument that is single byte and reports to use WriteByte instead",
			DocBefore:  "w.WriteRune('\\n')",
			DocAfter:   "w.WriteByte('\\n')",
			Rules: []ir.Rule{
				ir.Rule{
					Line: 223,
					SyntaxPatterns: []ir.PatternString{
						ir.PatternString{Line: 223, Value: "$w.WriteRune($c)"},
					},
					ReportTemplate:  "$$ => $w.WriteByte($c)",
					SuggestTemplate: "$w.WriteByte($c)",
					WhereExpr: ir.FilterExpr{
						Line: 224,
						Op:   ir.FilterAndOp,
						Src:  "m[\"w\"].Type.Implements(\"io.ByteWriter\") && (m[\"c\"].Const && m[\"c\"].Value.Int() < runeSelf)",
						Args: []ir.FilterExpr{
							ir.FilterExpr{
								Line:  224,
								Op:    ir.FilterVarTypeImplementsOp,
								Src:   "m[\"w\"].Type.Implements(\"io.ByteWriter\")",
								Value: "w",
								Args: []ir.FilterExpr{
									ir.FilterExpr{Line: 224, Op: ir.FilterStringOp, Src: "\"io.ByteWriter\"", Value: "io.ByteWriter"},
								},
							},
							ir.FilterExpr{
								Line: 224,
								Op:   ir.FilterAndOp,
								Src:  "(m[\"c\"].Const && m[\"c\"].Value.Int() < runeSelf)",
								Args: []ir.FilterExpr{
									ir.FilterExpr{
										Line:  224,
										Op:    ir.FilterVarConstOp,
										Src:   "m[\"c\"].Const",
										Value: "c",
									},
									ir.FilterExpr{
										Line: 224,
										Op:   ir.FilterLtOp,
										Src:  "m[\"c\"].Value.Int() < runeSelf",
										Args: []ir.FilterExpr{
											ir.FilterExpr{
												Line:  224,
												Op:    ir.FilterVarValueIntOp,
												Src:   "m[\"c\"].Value.Int()",
												Value: "c",
											},
											ir.FilterExpr{
												Line:  224,
												Op:    ir.FilterIntOp,
												Src:   "runeSelf",
												Value: int64(128),
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		ir.RuleGroup{
			Line:        232,
			Name:        "sliceClear",
			MatcherName: "m",
			DocTags: []string{
				"o1",
			},
			DocSummary: "Detects slice clear loops, suggests an idiom that is recognized by the Go compiler",
			DocBefore:  "for i := 0; i < len(buf); i++ { buf[i] = 0 }",
			DocAfter:   "for i := range buf { buf[i] = 0 }",
			Rules: []ir.Rule{
				ir.Rule{
					Line: 233,
					SyntaxPatterns: []ir.PatternString{
						ir.PatternString{Line: 233, Value: "for $i := 0; $i < len($xs); $i++ { $xs[$i] = $zero }"},
					},
					ReportTemplate:  "for ... { ... } => for $i := range $xs { $xs[$i] = $zero }",
					SuggestTemplate: "for $i := range $xs { $xs[$i] = $zero }",
					WhereExpr: ir.FilterExpr{
						Line: 234,
						Op:   ir.FilterEqOp,
						Src:  "m[\"zero\"].Value.Int() == 0",
						Args: []ir.FilterExpr{
							ir.FilterExpr{
								Line:  234,
								Op:    ir.FilterVarValueIntOp,
								Src:   "m[\"zero\"].Value.Int()",
								Value: "zero",
							},
							ir.FilterExpr{
								Line:  234,
								Op:    ir.FilterIntOp,
								Src:   "0",
								Value: int64(0),
							},
						},
					},
				},
			},
		},
		ir.RuleGroup{
			Line:        244,
			Name:        "utf8DecodeRune",
			MatcherName: "m",
			DocTags: []string{
				"o1",
			},
			DocSummary: "Detects expressions like []rune(s)[0] that may cause unwanted rune slice allocation",
			DocBefore:  "r := []rune(s)[0]",
			DocAfter:   "r, _ := utf8.DecodeRuneInString(s)",
			DocNote:    "See Go issue for details: https://github.com/golang/go/issues/45260",
			Rules: []ir.Rule{
				ir.Rule{
					Line: 251,
					SyntaxPatterns: []ir.PatternString{
						ir.PatternString{Line: 251, Value: "$ch := []rune($s)[0]"},
					},
					ReportTemplate:  "$$ => $ch, _ := utf8.DecodeRuneInString($ch)",
					SuggestTemplate: "$ch, _ := utf8.DecodeRuneInString($ch)",
					WhereExpr: ir.FilterExpr{
						Line: 252,
						Op:   ir.FilterAndOp,
						Src:  "m[\"s\"].Type.Is(`string`) && m.File().Imports(`unicode/utf8`)",
						Args: []ir.FilterExpr{
							ir.FilterExpr{
								Line:  252,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"s\"].Type.Is(`string`)",
								Value: "s",
								Args: []ir.FilterExpr{
									ir.FilterExpr{Line: 252, Op: ir.FilterStringOp, Src: "`string`", Value: "string"},
								},
							},
							ir.FilterExpr{
								Line:  252,
								Op:    ir.FilterFileImportsOp,
								Src:   "m.File().Imports(`unicode/utf8`)",
								Value: "unicode/utf8",
							},
						},
					},
				},
				ir.Rule{
					Line: 255,
					SyntaxPatterns: []ir.PatternString{
						ir.PatternString{Line: 255, Value: "$ch = []rune($s)[0]"},
					},
					ReportTemplate:  "$$ => $ch, _ = utf8.DecodeRuneInString($ch)",
					SuggestTemplate: "$ch, _ = utf8.DecodeRuneInString($ch)",
					WhereExpr: ir.FilterExpr{
						Line: 256,
						Op:   ir.FilterAndOp,
						Src:  "m[\"s\"].Type.Is(`string`) && m.File().Imports(`unicode/utf8`)",
						Args: []ir.FilterExpr{
							ir.FilterExpr{
								Line:  256,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"s\"].Type.Is(`string`)",
								Value: "s",
								Args: []ir.FilterExpr{
									ir.FilterExpr{Line: 256, Op: ir.FilterStringOp, Src: "`string`", Value: "string"},
								},
							},
							ir.FilterExpr{
								Line:  256,
								Op:    ir.FilterFileImportsOp,
								Src:   "m.File().Imports(`unicode/utf8`)",
								Value: "unicode/utf8",
							},
						},
					},
				},
				ir.Rule{
					Line: 261,
					SyntaxPatterns: []ir.PatternString{
						ir.PatternString{Line: 261, Value: "[]rune($s)[0]"},
					},
					ReportTemplate: "use utf8.DecodeRuneInString($s) here",
					WhereExpr: ir.FilterExpr{
						Line: 262,
						Op:   ir.FilterAndOp,
						Src:  "m[\"s\"].Type.Is(`string`) && !m.File().Imports(`unicode/utf8`)",
						Args: []ir.FilterExpr{
							ir.FilterExpr{
								Line:  262,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"s\"].Type.Is(`string`)",
								Value: "s",
								Args: []ir.FilterExpr{
									ir.FilterExpr{Line: 262, Op: ir.FilterStringOp, Src: "`string`", Value: "string"},
								},
							},
							ir.FilterExpr{
								Line: 262,
								Op:   ir.FilterNotOp,
								Src:  "!m.File().Imports(`unicode/utf8`)",
								Args: []ir.FilterExpr{
									ir.FilterExpr{
										Line:  262,
										Op:    ir.FilterFileImportsOp,
										Src:   "m.File().Imports(`unicode/utf8`)",
										Value: "unicode/utf8",
									},
								},
							},
						},
					},
				},
			},
		},
		ir.RuleGroup{
			Line:        270,
			Name:        "fprint",
			MatcherName: "m",
			DocTags: []string{
				"o1",
			},
			DocSummary: "Detects fmt.Sprint(f/ln) calls which can be replaced with fmt.Fprint(f/ln)",
			DocBefore:  "w.Write([]byte(fmt.Sprintf(\"%x\", 10)))",
			DocAfter:   "fmt.Fprintf(w, \"%x\", 10)",
			Rules: []ir.Rule{
				ir.Rule{
					Line: 271,
					SyntaxPatterns: []ir.PatternString{
						ir.PatternString{Line: 271, Value: "$w.Write([]byte(fmt.Sprint($*args)))"},
					},
					ReportTemplate:  "$$ => fmt.Fprint($w, $args)",
					SuggestTemplate: "fmt.Fprint($w, $args)",
					WhereExpr: ir.FilterExpr{
						Line:  272,
						Op:    ir.FilterVarTypeImplementsOp,
						Src:   "m[\"w\"].Type.Implements(\"io.Writer\")",
						Value: "w",
						Args: []ir.FilterExpr{
							ir.FilterExpr{Line: 272, Op: ir.FilterStringOp, Src: "\"io.Writer\"", Value: "io.Writer"},
						},
					},
				},
				ir.Rule{
					Line: 275,
					SyntaxPatterns: []ir.PatternString{
						ir.PatternString{Line: 275, Value: "$w.Write([]byte(fmt.Sprintf($*args)))"},
					},
					ReportTemplate:  "$$ => fmt.Fprintf($w, $args)",
					SuggestTemplate: "fmt.Fprintf($w, $args)",
					WhereExpr: ir.FilterExpr{
						Line:  276,
						Op:    ir.FilterVarTypeImplementsOp,
						Src:   "m[\"w\"].Type.Implements(\"io.Writer\")",
						Value: "w",
						Args: []ir.FilterExpr{
							ir.FilterExpr{Line: 276, Op: ir.FilterStringOp, Src: "\"io.Writer\"", Value: "io.Writer"},
						},
					},
				},
				ir.Rule{
					Line: 279,
					SyntaxPatterns: []ir.PatternString{
						ir.PatternString{Line: 279, Value: "$w.Write([]byte(fmt.Sprintln($*args)))"},
					},
					ReportTemplate:  "$$ => fmt.Fprintln($w, $args)",
					SuggestTemplate: "fmt.Fprintln($w, $args)",
					WhereExpr: ir.FilterExpr{
						Line:  280,
						Op:    ir.FilterVarTypeImplementsOp,
						Src:   "m[\"w\"].Type.Implements(\"io.Writer\")",
						Value: "w",
						Args: []ir.FilterExpr{
							ir.FilterExpr{Line: 280, Op: ir.FilterStringOp, Src: "\"io.Writer\"", Value: "io.Writer"},
						},
					},
				},
				ir.Rule{
					Line: 283,
					SyntaxPatterns: []ir.PatternString{
						ir.PatternString{Line: 283, Value: "io.WriteString($w, fmt.Sprint($*args))"},
					},
					ReportTemplate:  "$$ => fmt.Fprint($w, $args)",
					SuggestTemplate: "fmt.Fprint($w, $args)",
				},
				ir.Rule{
					Line: 286,
					SyntaxPatterns: []ir.PatternString{
						ir.PatternString{Line: 286, Value: "io.WriteString($w, fmt.Sprintf($*args))"},
					},
					ReportTemplate:  "$$ => fmt.Fprintf($w, $args)",
					SuggestTemplate: "fmt.Fprintf($w, $args)",
				},
				ir.Rule{
					Line: 289,
					SyntaxPatterns: []ir.PatternString{
						ir.PatternString{Line: 289, Value: "io.WriteString($w, fmt.Sprintln($*args))"},
					},
					ReportTemplate:  "$$ => fmt.Fprintln($w, $args)",
					SuggestTemplate: "fmt.Fprintln($w, $args)",
				},
			},
		},
		ir.RuleGroup{
			Line:        297,
			Name:        "writeString",
			MatcherName: "m",
			DocTags: []string{
				"o1",
			},
			DocSummary: "Detects w.Write calls which can be replaced with w.WriteString",
			DocBefore:  "w.Write([]byte(\"foo\"))",
			DocAfter:   "w.WriteString(\"foo\")",
			Rules: []ir.Rule{
				ir.Rule{
					Line: 298,
					SyntaxPatterns: []ir.PatternString{
						ir.PatternString{Line: 298, Value: "$w.Write([]byte($s))"},
					},
					ReportTemplate:  "$$ => $w.WriteString($s)",
					SuggestTemplate: "$w.WriteString($s)",
					WhereExpr: ir.FilterExpr{
						Line: 299,
						Op:   ir.FilterAndOp,
						Src:  "m[\"w\"].Type.Implements(\"io.StringWriter\") && m[\"s\"].Type.Is(`string`)",
						Args: []ir.FilterExpr{
							ir.FilterExpr{
								Line:  299,
								Op:    ir.FilterVarTypeImplementsOp,
								Src:   "m[\"w\"].Type.Implements(\"io.StringWriter\")",
								Value: "w",
								Args: []ir.FilterExpr{
									ir.FilterExpr{Line: 299, Op: ir.FilterStringOp, Src: "\"io.StringWriter\"", Value: "io.StringWriter"},
								},
							},
							ir.FilterExpr{
								Line:  299,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"s\"].Type.Is(`string`)",
								Value: "s",
								Args: []ir.FilterExpr{
									ir.FilterExpr{Line: 299, Op: ir.FilterStringOp, Src: "`string`", Value: "string"},
								},
							},
						},
					},
				},
			},
		},
		ir.RuleGroup{
			Line:        307,
			Name:        "writeBytes",
			MatcherName: "m",
			DocTags: []string{
				"o1",
			},
			DocSummary: "Detects w.WriteString calls which can be replaced with w.Write",
			DocBefore:  "w.WriteString(buf.String())",
			DocAfter:   "w.Write(buf.Bytes())",
			Rules: []ir.Rule{
				ir.Rule{
					Line: 312,
					SyntaxPatterns: []ir.PatternString{
						ir.PatternString{Line: 312, Value: "io.WriteString($w, $buf.String())"},
					},
					ReportTemplate:  "$$ => $w.Write($buf.Bytes())",
					SuggestTemplate: "$w.Write($buf.Bytes())",
					WhereExpr: ir.FilterExpr{
						Line: 313,
						Op:   ir.FilterOrOp,
						Src:  "isBuffer(m[\"buf\"])",
						Args: []ir.FilterExpr{
							ir.FilterExpr{
								Line:  313,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"buf\"].Type.Is(`bytes.Buffer`)",
								Value: "buf",
								Args: []ir.FilterExpr{
									ir.FilterExpr{Line: 309, Op: ir.FilterStringOp, Src: "`bytes.Buffer`", Value: "bytes.Buffer"},
								},
							},
							ir.FilterExpr{
								Line:  313,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"buf\"].Type.Is(`*bytes.Buffer`)",
								Value: "buf",
								Args: []ir.FilterExpr{
									ir.FilterExpr{Line: 309, Op: ir.FilterStringOp, Src: "`*bytes.Buffer`", Value: "*bytes.Buffer"},
								},
							},
						},
					},
				},
				ir.Rule{
					Line: 316,
					SyntaxPatterns: []ir.PatternString{
						ir.PatternString{Line: 316, Value: "io.WriteString($w, string($buf.Bytes()))"},
					},
					ReportTemplate:  "$$ => $w.Write($buf.Bytes())",
					SuggestTemplate: "$w.Write($buf.Bytes())",
					WhereExpr: ir.FilterExpr{
						Line: 317,
						Op:   ir.FilterOrOp,
						Src:  "isBuffer(m[\"buf\"])",
						Args: []ir.FilterExpr{
							ir.FilterExpr{
								Line:  317,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"buf\"].Type.Is(`bytes.Buffer`)",
								Value: "buf",
								Args: []ir.FilterExpr{
									ir.FilterExpr{Line: 309, Op: ir.FilterStringOp, Src: "`bytes.Buffer`", Value: "bytes.Buffer"},
								},
							},
							ir.FilterExpr{
								Line:  317,
								Op:    ir.FilterVarTypeIsOp,
								Src:   "m[\"buf\"].Type.Is(`*bytes.Buffer`)",
								Value: "buf",
								Args: []ir.FilterExpr{
									ir.FilterExpr{Line: 309, Op: ir.FilterStringOp, Src: "`*bytes.Buffer`", Value: "*bytes.Buffer"},
								},
							},
						},
					},
				},
				ir.Rule{
					Line: 320,
					SyntaxPatterns: []ir.PatternString{
						ir.PatternString{Line: 320, Value: "$w.WriteString($buf.String())"},
					},
					ReportTemplate:  "$$ => $w.Write($buf.Bytes())",
					SuggestTemplate: "$w.Write($buf.Bytes())",
					WhereExpr: ir.FilterExpr{
						Line: 321,
						Op:   ir.FilterAndOp,
						Src:  "m[\"w\"].Type.Implements(\"io.Writer\") && isBuffer(m[\"buf\"])",
						Args: []ir.FilterExpr{
							ir.FilterExpr{
								Line:  321,
								Op:    ir.FilterVarTypeImplementsOp,
								Src:   "m[\"w\"].Type.Implements(\"io.Writer\")",
								Value: "w",
								Args: []ir.FilterExpr{
									ir.FilterExpr{Line: 321, Op: ir.FilterStringOp, Src: "\"io.Writer\"", Value: "io.Writer"},
								},
							},
							ir.FilterExpr{
								Line: 321,
								Op:   ir.FilterOrOp,
								Src:  "isBuffer(m[\"buf\"])",
								Args: []ir.FilterExpr{
									ir.FilterExpr{
										Line:  321,
										Op:    ir.FilterVarTypeIsOp,
										Src:   "m[\"buf\"].Type.Is(`bytes.Buffer`)",
										Value: "buf",
										Args: []ir.FilterExpr{
											ir.FilterExpr{Line: 309, Op: ir.FilterStringOp, Src: "`bytes.Buffer`", Value: "bytes.Buffer"},
										},
									},
									ir.FilterExpr{
										Line:  321,
										Op:    ir.FilterVarTypeIsOp,
										Src:   "m[\"buf\"].Type.Is(`*bytes.Buffer`)",
										Value: "buf",
										Args: []ir.FilterExpr{
											ir.FilterExpr{Line: 309, Op: ir.FilterStringOp, Src: "`*bytes.Buffer`", Value: "*bytes.Buffer"},
										},
									},
								},
							},
						},
					},
				},
			},
		},
	},
}

